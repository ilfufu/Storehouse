## 后端
api大体按RESTful设计，但部分查询函数如登录的login函数由于输入参数结构比较复杂，本人初学不知道如何使用get处理，遂使用post处理，以后需要改进

为了方便前后端的通信查询，封装了后端返回的数据为不标准的报文，包括状态码（200表示成功，400表示失败）、信息（成功或者失败）、数据、数据长度，这样前端可以根据状态码快速判断http请求情况，然后进一步进入成功或者失败处理，简化了前端的判断逻辑

后端大部分逻辑采用了mybatis plus库的函数，判断查询时大多使用LambdaQueryWrapper的条件查询，因为理论上更安全，仅在需要关联不同数据库的记录管理使用了QueryWrapper的查询，因为查询逻辑比较复杂，而QueryWrapper可以写更接近sql语法的语句

数据库的设计不太好，这是因为开发的时间比较长，后面想到一些功能，受限于数据库不好实现（比如用户数据库，没有设计创建用户的创建人这一表列，影响了后面物品管理的设计），有点遗憾吧，以后也要改进

因为使用了mybatis plus库的内容比较多，mybatis的controller--mapper--service--implement--xml文件结构还是没太熟悉，还得多学多写多练

前端向后端发信息时，会出现跨域问题（目的地和当前的域名、协议、端口之一不同时出现，同源策略会阻止js脚本的运行），因为分离项目前端后端肯定跑在不同端口上，这里我选择在后端解决问题，通过重写WebMvcConfigurer解决全局的跨域问题

## 前端
前端主要使用了element ui库，主界面用到了菜单、下拉栏、容器、侧边栏、描述表这些组件，各个管理部分主要用到了表格、表单、弹窗、分页、按钮这些组件，使用也没什么特别的，按官网文档上介绍结合自己需求搞就行，比如表单的填写规则，按文档指导写就行，文档内容不够就查网上资料

信息在组件之间的传递就和之前学的一样，使用props、slot传递变量，用emit传递函数

由于反复点击可能引起重复导航问题，所以在router的配置中重写了push，添加了对重复导航问题的全局处理；同时因为不同权限用户的侧边栏菜单是不同的，因此写了重置路由的函数，登入登出时更新菜单，或者说更新routes

动态的侧边栏菜单数据比较复杂，不好直接存到sessionStorage，所以使用vuex库辅助存取

由于浏览器刷新会重置js环境，内存会清空，而vuex数据会默认存在内存，这样就会造成丢失，解决方法是引入persistedstate插件使vuex持久化，并选择使用sessionStorage，这样vuex数据存一份到sessionStorage，并用watch监听，发现重新加载时触发建立动态侧边栏的函数，从sessionStorage中取数据刷新